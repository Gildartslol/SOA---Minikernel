Memoria

Obtener ID del proceso.

PAra el proceso mas sencillo seguimos los siguientes pasos . 
	En Kernel.c creamos y rellenamos la funcion con lo correspondiente para su funcionamiento. En este caso muy sencillo 
	return p_proc_actual->id;
	A침adimos en la cabecera del kernel, kernel.h un hueco en el array de servicios para el nuevo servicio. Creando el prototipo de la funci칩n.
	En llamsis.h le asignamos un numero correspondiente de proceso para ejecutar.
	En serv.c creamos la llamada con el numero correspondiente y en serv.h el prototipo de esta llamada.


Dormir un proceso durante unos segundos.
	En kernel.c creamos y rellenamos la funcion sis_dormir de acorde a su funcionamiento.
	En la tabla BCP a침adimos dos campos 
	int inicio_bloqueo;		/* instante de bloqueo */
	int secs_bloqueo;		/* numero de segundos de bloqueo */
	Definimos una lista de procesos esperando en la cabcera del kernel.
	Rellenamos la funcion de tratamiento de interrupcion de reloj para que desbloquee un proceso si se ha cumplido su tiempo.
	Rellenamos el resto de cabeceras para el correcto llamamiento de la funcion dormir.

Contabilidad de procesos en modo usuario y modo sistema.

	En kernel.c creamos al funcion tiempos_proceso y la rellenamos de acuerdo a la l칩gica del programa. Marcamos con una variable global cuandoa accedemos a memoria por si da un excepcion en dicha zona poder evitar que se congele el sistema y solo se aborte el proceso.
	En la funcion simplemente volcamos los datos de cada proceso almacenado en su tabla de proceso correspondiente al numero de veces llamados en ejecucion o en sistema y los llevamos al struct global creado.


 Mutex

  	Para comenzar creamos todas las funciones y variables que especifica el enunciado, como un mutex struc compuesto de nombre, tipo, procesos con el mutex abierto y con el mutex bloqueado.

  	En abrir_mutex comporbamos que el mutex existe y procedemos a darle un descriptor.



  Round Robin

  	La implementacion del round robin es sencillam. Asignamos un parametro en la tabla de proceso ticksRestantesDRodaja. Al comienzo del planificador se lo estableceremos a la variable del sistema TICKS_POR_RODAJA. Y cuando llega un interrucion de reloj miraremos si este tiempo se ha consumido o no.